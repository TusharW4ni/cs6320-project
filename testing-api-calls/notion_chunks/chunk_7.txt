Let's use that page ID to read the sample content from the page. We'll use "16d8004e-5f6a-42a6-9811-51c22ddada12" as the block ID. Using this block_id , we retrieve the block children by sending a request to the endpoint . cURL JavaScript curl https://api.notion.com/v1/blocks/16d8004e-5f6a-42a6-9811-51c22ddada12/children?page_size=100 \ -H 'Authorization: Bearer '"$NOTION_API_KEY"'' \ -H "Notion-Version: <<latestNotionVersion>>" const { Client } = require('@notionhq/client'); const notion = new Client({ auth: process.env.NOTION_API_KEY }); (async () => { const blockId = '16d8004e5f6a42a6981151c22ddada12'; const response = await notion.blocks.children.list({ block_id: blockId, }); console.log(response); })(); You'll receive a response that contains a list of block objects. JavaScript { "object": "list", "results": [ { "object": "block", /* details omitted */ } ], "has_more": false, "next_cursor": null } This is a paginated response. Paginated responses are used throughout the Notion API when returning a potentially large list of objects. The maximum number of results in one paginated response is 100. The pagination reference explains how to use the "start_cursor" and "page_size" parameters to get more than 100 results. In this case, the individual child blocks we requested are in the "results" array. Reading nested blocks What happens when the results contain a block that has its own children? In this case, the response will not contain those children, but the has_children property will be true . If your integration needs a complete representation of a page's (or any block's) content, it should search the results for blocks with has_children set to true , and recursively call the retrieve block children endpoint. Reading large pages may take some time. We recommend using asynchronous operations in your architecture, such as a job queue. You will also need to be mindful of rate limits to appropriately slow down making new requests after the limit is met. Appending blocks to a page Integrations can add more content to a page by using the append block children endpoint. Let's try to add another block to the page we created in the example above. This endpoint requires two parameters: block_id and children . The block_id parameter is the ID of any existing block. If you're following from the example above, let's use the same page ID as the block ID: "16d8004e-5f6a-42a6-9811-51c22ddada12" . The children parameter is a list of block objects which describe the content we want to append. Let's use some more sample content: JavaScript [ { "object": "block", "type": "paragraph", "paragraph": { "text": [{ "type": "text", "text": { "content": "– Notion API Team", "link": { "type": "url", "url": "https://twitter.com/NotionAPI" } } }] } } ] Using both parameters, we append blocks by sending a request to the endpoint . cURL JavaScript curl -X PATCH https://api.notion.com/v1/blocks/16d8004e-5f6a-42a6-9811-51c22ddada12/children \ -H 'Authorization: Bearer '"$NOTION_API_KEY"'' \ -H "Content-Type: application/json" \ -H "Notion-Version: 2022-06-28" \ --data '{ "children": [ { "object": "block", "type": "paragraph", "paragraph": { "text": [{ "type": "text", "text": { "content": "– Notion API Team", "link": { "type": "url", "url": "https://twitter.com/NotionAPI" } } }] } } ] }' const { Client } = require('@notionhq/client'); const notion = new Client({ auth: process.env.NOTION_API_KEY }); (async () => { const blockId = '16d8004e5f6a42a6981151c22ddada12'; const response = await notion.blocks.children.append({ block_id: blockId, children: [ { object: 'block', type: 'paragraph', paragraph: { text: [ { type: 'text', text: { content: '– Notion API Team', link: { type: 'url', url: 'https://twitter.com/NotionAPI', }, }, }, ], }, }, ], }); console.log(response); })(); You'll receive a response that contains the updated block.